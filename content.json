{"meta":{"title":"尛孟的博客","subtitle":"想法总是无法付诸实践…","description":"与人联系甚少","author":"尛孟","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-01-04T10:07:23.000Z","updated":"2018-01-09T05:13:36.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-01-04T10:07:40.000Z","updated":"2018-01-09T13:16:03.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我 秦始皇 打钱"},{"title":"tags","date":"2018-01-04T10:07:33.000Z","updated":"2018-01-09T05:13:28.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js逻辑层","slug":"js逻辑层","date":"2018-01-10T12:55:16.000Z","updated":"2018-01-12T04:29:57.000Z","comments":true,"path":"2018/01/10/js逻辑层/","link":"","permalink":"http://yoursite.com/2018/01/10/js逻辑层/","excerpt":"","text":"逻辑层 在.js文件中使用了JavaScript语言,此外小程序增加了 Page(){}创建页面 data{}初始化数据 各种生命周期函数 页面相关事件处理函数(如onPullDownRefresh、onReachBottom、onPageScroll等) setData从逻辑层向视图层异步发送数据 以及微信提供调用原生API 但是需要注意的是js在 web 中一些能力无法使用，如 document，window 等 Page() 像在App.js中调用App()创建小程序实例一样,在页面.js中调用Page()就能注册该页面实例,同时要给该方法传递一个Object对象,这个对象包括了页面的初始数据、生命周期函数、事件处理函数等. data:{} 这个对象中设置的数据是页面初始化渲染的数据,要求必须是可以转json的数据类型 在.js定义的变量名,在.WXML中可以直接使用(object 内容在页面加载时会进行一次深拷贝，需考虑数据大小对页面加载的开销) 123456Page(&#123; data: &#123; text: 'init data', array: [&#123;msg: '1'&#125;, &#123;msg: '2'&#125;] &#125;&#125;) 12&lt;view&gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;array[0].msg&#125;&#125;&lt;/view&gt; 生命周期函数 页面相关事件处理函数 页面绑定事件处理函数​ 除了上面这些处理事件,页面还可以绑定一些用户交互相关事件,比如点击、拖拽、长按等,可以通过bind/catch+事件名,具体可以参考事件绑定 setData() 调用setData()可以从逻辑层向视图层传递数据(异步),但是直接修改this.Data页面不会改变还会操作数据不一致的问题 单次设置有1024K的大小设置 任何的value都不能设置为undefined 模块化部分逻辑是公共处理的,可以抽离到一个单独的.js文件,通过 module.exports 或者exports对外暴露接口 然后在需要使用的文件中使用 require(path)将公共代码引入 其他 可以通过Page.prototype.route 获取当前页面的路径 通过getapp()获取全局的应用实例,也就是小程序实例 getCurrentPages()可以获取当前页面栈的实例,获得的是一个数组,最后一个元素为当前页面 路由方式 wx.navigateTo、wx.redirectTo、导航跳转,只能打开非tabBar页面 wx.switchTab只能打开tabBar页面 wx.reLaunch可以打开任意页面 除了这些可使用的方法之外,小程序开发框架还提供了丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能 #####","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"},{"name":"框架学习","slug":"小程序/框架学习","permalink":"http://yoursite.com/categories/小程序/框架学习/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"初识小程序","slug":"初识小程序","date":"2018-01-10T09:12:36.000Z","updated":"2018-01-12T03:41:23.000Z","comments":true,"path":"2018/01/10/初识小程序/","link":"","permalink":"http://yoursite.com/2018/01/10/初识小程序/","excerpt":"","text":"微信小程序中就四种类型的文件 js ———- JavaScrip文件,负责页面逻辑 json ——– 项目配置文件，负责窗口颜色等等 wxml ——- 类似HTML文件,负责页面结构 wxss ——- 类似CSS文件,负责页面样式表 小程序的IDE每次编译都会自动整合这四种类型的文件,所以要求都是同名且同路径 每创建一个程序时,在根目录下就会生成app.json , app.js , app.wxss , app.wxml,相当于程序入口main app.json app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 必须要有这个文件，如果没有这个文件，IDE会报错，因为微信框架把这个作为配置文件入口，最简单只需创建这个文件，里面写个大括号就行 app.js 必须要有这个文件，没有也是会报错的！但是这个文件创建一下就行可以什么都不需要写 以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 这个文件不是必须的。因为它只是个全局CSS样式文件 页面的WXSS都可以覆盖它的样式 app.wxml 这个也不是必须的，而且这个并不是指主界面哦~因为小程序的主页面是靠在JSON文件中配置来决定的 根目录下的 .js .WXML .js app.js创建App实例App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。 app.jsonjson文件负责配置页面路径,tabBar的表现,网络超时时间等 这里的pages是配置程序的每一个页面的相对路径,页面的创建通过在对应页面的js文件中调用page()来创建 创建新的Page页面 .js注册页面Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。 12345678910111213141516171819202122232425262728293031323334353637383940414243Page(&#123; data: &#123;//页面初始数据 text: \"This is page data.\" &#125;, onLoad: function(options) &#123;//页面加载 必须是可转json的数据类型 // Do some initialize when page load. &#125;, onReady: function() &#123;//渲染完成 // Do something when page ready. &#125;, onShow: function() &#123;//页面显示 // Do something when page show. &#125;, onHide: function() &#123;//页面隐藏 // Do something when page hide. &#125;, onUnload: function() &#123;//页面卸载/销毁 // Do something when page close. &#125;, onPullDownRefresh: function() &#123;//用户下拉动作 // Do something when pull down. &#125;, onReachBottom: function() &#123;//上拉触底 // Do something when page reach bottom. &#125;, onShareAppMessage: function () &#123;//点击右上角转发 // return custom share data when user share. &#125;, onPageScroll: function() &#123;//页面滚动时间 // Do something when page scroll &#125;, // Event handler. viewTap: function() &#123;//页面其他绑定事件处理函数 this.setData(&#123; text: 'Set some data for updating view.' &#125;, function() &#123; // this is setData callback &#125;) &#125;, customData: &#123; hi: 'MINA' &#125;&#125;) .WXML结合数据绑定、列表渲染、条件渲染、模板、事件、引用，可以构建出页面的结构。 数据绑定 在.js中的data{}中申请的变量都可以在.WXML中使用 在.WXML通过 Mustache 语法(双大括号)就可以使用变量 数据绑定有多种绑定方式—简单绑定,组件属性,控制属性,关键字,运算表达式 除了简单绑定之外其余都徐亚把双大括号在双引号之内 1&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt; 绑定事件 因此,如果需要在.WXML中绑定某个事件,那就在标签内添加绑定函数 然后在.js中定义该函数的代码块 123456789&lt;view&gt; &lt;text catchtap=\"click\" class=\"window\"&gt;Hello&lt;/text&gt;&lt;/view&gt;....然后在.js文件中就可以定义函数.........click:function()&#123; console.log(\"点击了文字\"); &#125;, 列表渲染 在.WXML组件上使用 wx:for 可以让属性绑定一个数组,相当于遍历该数组重复渲染 默认数组的元素变量名为 item , 下标变量名为 index 用ws:for-item=&quot;xxx&quot;可以指定变量名为xxx 同理ws:for-index=&quot;xxx&quot;可以指定下标变量名 1234567891011121314&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;.................................Page(&#123; data: &#123; array: [&#123; message: &apos;foo&apos;, &#125;, &#123; message: &apos;bar&apos; &#125;] &#125;&#125;) 上面这种写法,是写在标签内,只能对一个标签起作用,但是如果同时需要对多个标签都使用该渲染方法的话,可以使用block标签.( 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。) 12345&lt;block wx:for=\"&#123;&#123;[1 , 2 , 3]&#125;&#125; wx:for-index=\"idx\" wx:for-item=\"itemName\"\"&gt; &lt;view&gt;&#123;&#123;idx&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;itemName&#125;&#125;&lt;/view&gt; ...xxx&lt;/block&gt; 条件渲染 在.WXML组件上使用 wx:if 可以判断是否需要渲染该代码块 也可以用 wx:elif和 wx:else来添加一个 else 块 123&lt;view wx:if=\"&#123;&#123;length &gt; 5&#125;&#125;\"&gt; 1 &lt;/view&gt;&lt;view wx:elif=\"&#123;&#123;length &gt; 2&#125;&#125;\"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 跟wx:for一样,wx:if也可以使用&lt;block&gt;标签将多个组件包装起来 在block标签上使用wx:if控制 1234&lt;block wx:if=\"&#123;&#123;true&#125;&#125;\"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; .WXSS用于描述 WXML 的组件样式,用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。与 CSS 相比，WXSS 扩展的特性有： 尺寸单位(小程序使用rpx,底层根据屏幕宽度进行自适应) 样式导入(用@import+外联样式表绝对路径 可以导入外联样式表) 内联样式框架组件上支持使用 style、class 属性来控制组件的样式。 style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 &lt;view style=&quot;color:;&quot; /&gt; class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。(小程序基本都是通过在.WXSS中定义样式类,在.WXML标签中直接使用,在.js中改变标签类名) &lt;view class=&quot;normal_view&quot; /&gt;","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"},{"name":"框架学习","slug":"小程序/框架学习","permalink":"http://yoursite.com/categories/小程序/框架学习/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"NSdate+NSCalendar操作","slug":"NSdate+NSCalendar操作","date":"2018-01-10T06:03:34.000Z","updated":"2018-01-10T06:43:33.000Z","comments":true,"path":"2018/01/10/NSdate+NSCalendar操作/","link":"","permalink":"http://yoursite.com/2018/01/10/NSdate+NSCalendar操作/","excerpt":"","text":"前言: 由于查询数据库时查询条件需要传递日期来获取某个月份的数据列表,如果传的时该月的某一天会导致拿到数据不全,如果传了该月的第一天会导致拿到的数据并不是当月的;而如果刚好查询当前月份的数据是不能用这个月的最后一天只能用当天来查询,于是有了以下的日历操作 首先,想要直接得到某个日期的NSDate,可以通过dateWithTimeInterval,与某个日期的毫秒差来获取,但是这个方法前提是需要知道基点日期,就算以当前的Date来计算,毫秒的计算也得自己去写清楚;比较麻烦,这时候可以通过日历对象的NSDateComponents来方便地定制指定日期,以下是两个NSDate分类方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//这个方法可以获取某个与当前NSDate对象指定间隔的日期//这里传的year.month 等都可以有正负,正数表示该日期之后的,负数表示该日期之前- (instancetype)getDateFromDateWithYear:(NSInteger)year month:(NSInteger)month day:(NSInteger)day hours:(NSInteger)hour minute:(NSInteger)minute second:(NSInteger)second&#123; //创建一个工具，一个封装了具体年月日、时秒分、周、季度等的类 // NSDateComponents* dateComponents = [[NSDateComponents alloc]init]; NSDateComponents* dateComponents; //创建一个日历，它提供了大部分的日期计算接口，并且允许在NSDate和NSDateComponents之间转换 NSCalendar *dateCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; // NSDate 转 NSDateComponents所需要设置的值，可根据需要自己设置，这里是年～秒全部获取，如果某个没有写的话，比如NSCalendarUnitHour，转成NSDateComponents后，会是一个很大或很小的数 NSInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitWeekday | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; //为dateComponents获取值，该值等价于self的各个部件 dateComponents = [dateCalendar components:unitFlags fromDate:self]; //创建一个NSDateComponents，开始设置想要的时间 NSDateComponents *myCompoentes = [[NSDateComponents alloc]init]; [myCompoentes setYear:dateComponents.year + year]; [myCompoentes setMonth:dateComponents.month + month]; [myCompoentes setDay:dateComponents.day + day]; [myCompoentes setHour:dateComponents.hour + hour]; [myCompoentes setMinute:dateComponents.minute + minute]; [myCompoentes setSecond:dateComponents.second + second]; //把通过myCompoentes设置的值转为NSDate格式，这个NSDate就是想要的时间 NSDate *myDate = [dateCalendar dateFromComponents:myCompoentes]; return myDate;&#125;//这个方法可以直接更改某个日期的某个组件 参数传-1表示不改变- (instancetype)setDateWithYear:(NSInteger)year month:(NSInteger)month day:(NSInteger)day hours:(NSInteger)hour minute:(NSInteger)minute second:(NSInteger)second&#123; //创建一个工具，一个封装了具体年月日、时秒分、周、季度等的类 NSDateComponents* dateComponents; //创建一个日历，它提供了大部分的日期计算接口，并且允许在NSDate和NSDateComponents之间转换 NSCalendar *dateCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; dateComponents = [dateCalendar components:unitFlags fromDate:self]; //创建一个NSDateComponents，开始设置想要的时间 NSDateComponents *myCompoentes = [[NSDateComponents alloc]init]; year != -1 ? [myCompoentes setYear:year] : [myCompoentes setYear:dateComponents.year]; month != -1 ? [myCompoentes setMonth:month] : [myCompoentes setMonth:dateComponents.month]; day != -1 ? [myCompoentes setDay:day] : [myCompoentes setDay:dateComponents.day]; hour != -1 ? [myCompoentes setHour:hour] : [myCompoentes setHour:dateComponents.hour]; minute != -1 ? [myCompoentes setMinute: minute : [myCompoentes setMinute:dateComponents.minute]; second != -1 ? [myCompoentes setSecond:second] : [myCompoentes setSecond:dateComponents.second]; //把通过myCompoentes设置的值转为NSDate格式，这个NSDate就是想要的时间 NSDate *myDate = [dateCalendar dateFromComponents:myCompoentes]; return myDate;&#125; 接下来要分析如何得到某个月份的最后一天,由于每个月的天数的不一样,还有2月这个特殊存在,不好使用穷尽判断的方式来设置.这时候就想到日历对象对日期的操作,结合上面两个方法,轻而易举的就实现了 123456789- (NSDate *)getMonthLastDate&#123; //先设置为1号,因为比如10月份如果是刚好是31号然后让它月份+1,会导致得到的日期变成12月的1号而不是11月30号 NSDate *firstDate = [self setDateWithYear:-1 month:-1 day:1 hours:0 minute:0 second:0]; //再让月份+1 ,这样就得到了下个月的1号 NSDate *nextMonthDate = [firstDate getDateFromDateWithYear:0 month:1 day:0 hours:0 minute:0 second:0]; //最后让已经是1号的NSDate天数-1, 就得到了本月的最后一天了 NSDate *monthLastDate = [nextMonthDate getDateFromDateWithYear:0 month:0 day:-1 hours:0 minute:0 second:0]; return monthLastDate;&#125; 这里有个小插曲,就是如果需要拿当前月份的数据的时候,不能传这个月的最后一天,只能传当前Date,因此需要判断NSDate是否是当月 12345678910- (BOOL)isThisMonth&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSCalendarUnit unit = NSCalendarUnitYear | NSCalendarUnitMonth; // 获得某个时间的年月 NSDateComponents *dateCmps = [calendar components:unit fromDate:self]; //与当前日期比较 NSDateComponents *nowCmps = [calendar components:unit fromDate:[NSDate date]]; return dateCmps.year == nowCmps.year &amp;&amp; dateCmps.month == nowCmps.month;&#125; 如果需要判断得到的日期是否是周末 123456789101112- (BOOL)isWeekend&#123; //计算week数 NSCalendar * myCalendar = [NSCalendar currentCalendar]; myCalendar.timeZone = [NSTimeZone systemTimeZone]; NSInteger week = [[myCalendar components:NSCalendarUnitWeekday fromDate:self] weekday]; //国际日期中1是周日 7是周六 , 其他2~6对应星期一~星期五 switch (week) &#123; case 1: &#123; return YES; &#125; case 7: &#123; return YES; &#125; default: &#123; return NO; &#125; &#125;&#125;","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[]},{"title":"限制键盘输入字符/位数","slug":"限制键盘输入字符:位数","date":"2018-01-10T05:25:07.000Z","updated":"2018-01-10T06:10:23.000Z","comments":true,"path":"2018/01/10/限制键盘输入字符:位数/","link":"","permalink":"http://yoursite.com/2018/01/10/限制键盘输入字符:位数/","excerpt":"","text":"前言:很多情况下，输入框都是需要按照要求进行输入。例如：密码输入框只能输入纯数字或者是拼音与数字结合的文本等，那么我们在开发的时候就需要做一些输入文本的限制。当然,以下的方法都可以使用正则来实现,找个时间我顺便把正则也给补充上来~ 只能输入纯数字 在这里以UITextField为例：其实现代码如下： 12345678910#define Numbers @&quot;1234567890&quot;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; //invertedSet方法是去反字符,把所有的除了Numbers里的字符都找出来(包含去空格功能) NSCharacterSet *cs = [[NSCharacterSet characterSetWithCharactersInString:Numbers invertedSet];//利用上述得到的反字符集合分割原有字符串,并且重新拼接起来就得到纯数字字符串 NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@&quot;&quot;];// 如果重新拼接起来的字符串和原字符串相同说明没有其他字符 return [string isEqualToString:filtered];&#125; 只能输入纯大小写字母 和以上只能输入纯数字类似，实现起来简单，只需要宏定义 12345678#define LETTER @&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; NSCharacterSet *cs = [[NSCharacterSet characterSetWithCharactersInString:LETTER] invertedSet]; NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@&quot;&quot;]; return [string isEqualToString:filtered]; &#125; 大小写字母和数字结合输入 方法类似上面的做法 1#define LETTER_NUMBER @&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; 同样道理,具体能够输入哪些内容如果输入内容能够一一列举的话我们就可以通过define来设置了，实现起来超简单。 限制只能输入中文 在这里用到了观察者(因为其实通过联想/复制输入是不会走shouldChangeCharactersInRange代理方法的,会导致联想输入的中文没法控制,所以需要通过KVO监听 , 不过有时候我一般选择直接关掉联想,世界清静~~) 12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; _myTextField.delegate = self; [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFiledEditChanged:) name:UITextFieldTextDidChangeNotification object:_myTextField];&#125;- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123; [textField resignFirstResponder]; //过滤非汉字字符 textField.text = [self filterCharactor:textField.text withRegex:@&quot;[^\\u4e00-\\u9fa5]&quot;]; //截四位汉字 if (textField.text.length &gt;= 4) &#123; textField.text = [textField.text substringToIndex:4]; &#125; return NO;&#125;- (void)textFiledEditChanged:(id)notification&#123; UITextRange *selectedRange = _myTextField.markedTextRange; UITextPosition *position = [_myTextField positionFromPosition:selectedRange.start offset:0]; if (!position) &#123; //// 没有高亮选择的字 //过滤非汉字字符 _myTextField.text = [self filterCharactor:_myTextField.text withRegex:@&quot;[^\\u4e00-\\u9fa5]&quot;]; if (_myTextField.text.length &gt;= 4) &#123; _myTextField.text = [_myTextField.text substringToIndex:4]; &#125; &#125;else &#123; //有高亮文字 //do nothing &#125;&#125;- (NSString *)filterCharactor:(NSString *)string withRegex:(NSString *)regexStr&#123; NSString *searchText = string; NSError *error = NULL; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexStr options:NSRegularExpressionCaseInsensitive error:&amp;error]; NSString *result = [regex stringByReplacingMatchesInString:searchText options:NSMatchingReportCompletion range:NSMakeRange(0, searchText.length) withTemplate:@&quot;&quot;]; return result; &#125; 如果要限制输入字符位数的话可以直接设置，这个实现上有很多种，最简单的就是 123456- (void)textViewDidChange:(UITextView *)textView&#123; NSInteger number = [textView.text length]; if (number &gt; 300) &#123; textView.text = [textView.text substringToIndex:300]; &#125;&#125; 如果输入框是金额类数字,需要限制小数点前小数点后位数可以用下面的分类方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; return [NSString limitPayMoneyDot:textField shouldChangeCharactersInRange:range replacementString:string dotPreBits:10 dotAfterBits:2];&#125;+ (BOOL) limitPayMoneyDot:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string dotPreBits:(int)dotPreBits dotAfterBits:(int)dotAfterBits&#123; static NSString *myDotNumbers = @&quot;0123456789.\\n&quot;; static NSString *myNumbers = @&quot;0123456789\\n&quot;; /********** 过滤各种情况 **********/ if ([string isEqualToString:@&quot;\\n&quot;] || [string isEqualToString:@&quot;&quot;]) &#123; //按下return return YES; &#125; //当设置小数点后位数为0时不能输入小数点 if([string isEqualToString:@&quot;.&quot;] &amp;&amp; dotAfterBits == 0)&#123; return NO; &#125; //首位不能是小数点 | 不能多个小数点 | 不能首位多个0 | 小数点后最后一位不能是0 if(([string isEqualToString:@&quot;.&quot;] &amp;&amp; textField.text.length == 0) || ([textField.text containsString:@&quot;.&quot;] &amp;&amp; [string isEqualToString:@&quot;.&quot;]) || ([string isEqualToString:@&quot;0&quot;] &amp;&amp; [textField.text isEqualToString:@&quot;0&quot;]))&#123; return NO; &#125; /********** 开始限制逻辑 **********/ NSCharacterSet *cs; NSUInteger nDotLoc = [textField.text rangeOfString:@&quot;.&quot;].location; //不能0.00000, 也就是前面都是0的情况下小数点最后一位不能是0 if (nDotLoc != NSNotFound &amp;&amp; range.location == nDotLoc + dotAfterBits ) &#123; float number = [textField.text floatValue]; if (number == 0 &amp;&amp; [string isEqualToString:@&quot;0&quot;]) &#123; return NO; &#125; &#125; if (NSNotFound == nDotLoc &amp;&amp; 0 != range.location)//整数 &#123; //去空格去数字 cs = [[NSCharacterSet characterSetWithCharactersInString:myNumbers] invertedSet]; if ([string isEqualToString:@&quot;.&quot;]) &#123; return YES; &#125; //超过整数位数限制 if (textField.text.length &gt;= dotPreBits) &#123; return NO; &#125; &#125; else //非整数 &#123; cs = [[NSCharacterSet characterSetWithCharactersInString:myDotNumbers] invertedSet]; if (textField.text.length &gt;= dotPreBits + dotAfterBits + 1) &#123; //超过位数限制 return NO; &#125; &#125; //过滤 NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs] componentsJoinedByString:@&quot;&quot;]; BOOL basicTest = [string isEqualToString:filtered]; if (!basicTest) &#123; //输入了非法字符 return NO; &#125; if (NSNotFound != nDotLoc &amp;&amp; range.location &gt; nDotLoc + dotAfterBits) &#123; //超过位数限制 return NO; &#125; return YES;&#125;","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"调起QQ临时会话","slug":"调起QQ临时会话","date":"2018-01-10T03:27:52.000Z","updated":"2018-01-10T06:06:00.000Z","comments":true,"path":"2018/01/10/调起QQ临时会话/","link":"","permalink":"http://yoursite.com/2018/01/10/调起QQ临时会话/","excerpt":"","text":"前言:前段时间项目中有个需求,在App内调起QQ客户端和客服发起临时会话. QQ开发者平台,并没有找到App调用QQ客户端发起临时会话方法,(只提供了网页端接入方法) 网上搜到的一些方法,大部分都粗秒淡写,要么可以调用QQ客户端,不能成功发送消息,要么是其他问题.并且大部分只是说明了调起普通版QQ的方法,当用户没有安装普通QQ而且安装了国际版QQi或者TIM的时候那些方法都是无效的 网上还有说接收临时消息的QQ号要开通QQ推广功能,没有开通的是接收不了陌生人消息的…但是我自己用个人QQ都可以…. 注意 调起临时会话的话记得考虑用户没安装QQ而是安装了国际版QQi或者TIM，因为他们的Scheme是不一样的….此外，从外部APP打开TIM会导致TIM卡死（我不知道这是神马bug，然而网上大部分只是打开QQ没考虑后两种情况所以也查不到什么原因，官网自然也是啥都没提到…） 使用方法 将各版本Schemes添加到项目plist文件白名单中(iOS9新出要求),方法如下: 在项目info.plist添加LSApplicationQueriesSchemes字段 类型Array 在此Array中添加各个需要的QQ版本的Schemes 直接上代码: 123456789101112131415if (![self OpenUrl:[NSString stringWithFormat:@&quot;mqq://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,ServiceQQNumber]]) &#123;//QQ if(![self OpenUrl:[NSString stringWithFormat:@&quot;mqqiapi://im/chat?chat_type=wpa&amp;uin=%@&amp;version=1&amp;src_type=web&quot;,ServiceQQNumber]])&#123;//国际版QQi //if(![self OpenUrl:@&quot;TIM://&quot;])&#123;//TIM //测试打开后会卡死 [xxHUD showError:@&quot;无法打开,清先安装QQ&quot;]; // &#125; &#125; &#125;- (BOOL)OpenUrl:(NSString *)url&#123; if([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:url]])&#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; return YES; &#125;else&#123; return NO; &#125;&#125;","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"html中的文本级/容器级标签与css中的块级/行内元素","slug":"html中的文本级:容器级标签与css中的块级:行内元素","date":"2018-01-09T07:59:34.000Z","updated":"2018-01-10T03:14:01.000Z","comments":true,"path":"2018/01/09/html中的文本级:容器级标签与css中的块级:行内元素/","link":"","permalink":"http://yoursite.com/2018/01/09/html中的文本级:容器级标签与css中的块级:行内元素/","excerpt":"","text":"html中的文本级/容器级标签与css中的块级/行内元素 块级元素 霸占一行，不能与其他任何元素并列 能 接受宽、高 如果不设置宽度，那么宽度将默认变为父亲的100%。 行内元素 与 其他行内元素并排 不能 设置宽、高。默认的宽度，就是文字的宽度。 在HTML中，已经将标签分过类：文本级、容器级。 文本级：p、span、a、b、i、u、em 容器级：div、h系列、li、dt、ddCSS的分类和上面的很像，就p不一样： 所有的文本级标签，都是行内元素，除了p，p是个文本级，但是是个块级元素。 所有的容器级标签都是块级元素。 块级元素和行内元素的相互转换 块级元素可以设置为行内元素 行内元素可以设置为块级元素 12345div&#123; display: inline; background-color: pink; width: 500px; height: 500px;&#125; display是“显示模式”的意思，用来改变元素的行内、块级性质 inline就是“行内”。 一旦，给一个标签设置 display: inline; 那么，这个标签将立即变为行内元素。此时它和一个span无异： 此时这个div不能设置宽度、高度； 此时这个div可以和别人并排了同样的道理， 12345span&#123; display: block; width: 200px; height: 200px; background-color: pink;&#125; “block”是“块”的意思让标签变为块级元素。此时这个标签，和一个div无异： 此时这个span能够设置宽度、高度 此时这个span必须霸占一行了，别人无法和他并排 如果不设置宽度，将撑满父亲 标准流里面限制非常多，标签的性质恶心。比如，如果需要盒子并排、并且需要设置宽高。所以，移民！脱离标准流！ css中一共有三种手段，使一个元素脱离标准文档流： 浮动 绝对定位 固定定位","categories":[{"name":"html+css+js","slug":"html-css-js","permalink":"http://yoursite.com/categories/html-css-js/"},{"name":"样式表","slug":"html-css-js/CSS","permalink":"http://yoursite.com/categories/html-css-js/CSS/"}],"tags":[{"name":"html+css+js","slug":"html-css-js","permalink":"http://yoursite.com/tags/html-css-js/"}]},{"title":"沙盒文件夹的作用和选择","slug":"沙盒文件夹的作用和选择","date":"2016-04-18T10:56:00.000Z","updated":"2018-01-09T03:56:54.000Z","comments":true,"path":"2016/04/18/沙盒文件夹的作用和选择/","link":"","permalink":"http://yoursite.com/2016/04/18/沙盒文件夹的作用和选择/","excerpt":"","text":"沙盒大家都知道，但是平时要存储数据时总不知道存到哪里去才是正确的选择，这次就来聊聊每一个文件夹的作用和使用时该怎么选择 先来了解每一个文件夹的基本作用 • Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。• tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录• Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据• Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录 （看完还是不知道到底存哪里比较好啊喂(╯’ - ‘)╯︵ ┻━┻ ） – Documents– 需要保存由”应用程序本身”产生的文件或者数据，例如：游戏进度、涂鸦软件的绘图信息– 目录中的文件会被自动保存在 iClioud– 注意 ： 不要保存从网络上下载的文件，否则会无法上架 – Caches– 保存临时文件，”后续需要使用”，例如：缓存图片、离线数据(地图数据等)– 系统不会清零 cache 目录中的文件 –&gt; 因此要求程序开发时，”必须提供 cache 目录的清理解决方案” – Preference– 用户偏好设置，使用 NSUserDefault 直接读写 – Tmp– 保存临时文件，”后续不需要使用”– tmp 目录中的文件，系统会自动清零– 重新启动手机时，tmp 目录会被情况– 系统磁盘空间不足时，系统也会自动清理","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原生应用","slug":"iOSDevelopment/Native","permalink":"http://yoursite.com/categories/iOSDevelopment/Native/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"代理/通知/KVO 的区别","slug":"代理:通知:KVO 的区别","date":"2016-04-16T17:15:00.000Z","updated":"2018-01-09T03:49:51.000Z","comments":true,"path":"2016/04/17/代理:通知:KVO 的区别/","link":"","permalink":"http://yoursite.com/2016/04/17/代理:通知:KVO 的区别/","excerpt":"","text":"通知 NSNotification、通知中心 NSNotificationCenter◦ 任何对象之间都可以传递消息(一般在层级结构比较深又需要传值的情况) 使用范围▪ 1个对象可以发通知给多个对象▪ 1个对象可以接受多个对象发出的通知◦ 要求:必须得保证通知的名字在发出和监听时是一致的 KVO◦ 仅仅是能监听对象属性的改变（灵活度不如通知和代理） 代理模式 使用范围▪ 1个对象只能设置一个代理(假设这个对象只有1个代理属性)▪ 1个对象能成为多个对象的代理 如何选择?◦ 代理比通知规范，非常适合多人开发以及代码维护◦ 如果要通知多个对象,就用通知 ◦ 建议使用代理多于通知,能使用代理尽量使用代理◦ 当层级结构非常深，难以拿到对应对象时使用通知","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"面试问题","slug":"iOSDevelopment/InterviewFAQ","permalink":"http://yoursite.com/categories/iOSDevelopment/InterviewFAQ/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"纠正网上大部分文章对UITableView分割线的不正确认识","slug":"纠正网上大部分文章对UITableView分割线的不正确认识","date":"2016-04-16T06:04:00.000Z","updated":"2018-01-09T12:54:52.000Z","comments":true,"path":"2016/04/16/纠正网上大部分文章对UITableView分割线的不正确认识/","link":"","permalink":"http://yoursite.com/2016/04/16/纠正网上大部分文章对UITableView分割线的不正确认识/","excerpt":"","text":"本篇文章主要有两个内容:1. 正确认识全屏分割线的设置 2. 去除没有数据的Cell或者指定Cell的分割线 毕竟这里只是我自己本人的看法和总结 – 有什么建议或者觉得我说得不好的地方，欢迎互相探讨。毕竟探讨越多提升越大~~ —-PART One—-首先是我一直觉得很不爽的全屏分割线(为何不爽,看完这一部分大家应该也能理解我的感受) 自定义Cell的情况 把系统的分割线隐藏,然后自己创建一个高度为1的UIVIew添加到Cell的底部或者顶部 把系统的分割线隐藏,然后设置tableview的背景色为自己想要的分割线颜色，重写Cell的setFrame方法，把高度减1(需要的话还可以把宽度也减一点点，会有不一样的效果~) 设置Cell的1- 或者设置tableview的```separatorInset = UIEdgeInsetsZero```、再设置Cell的 ```layoutMargins = UIEdgeInsetsZero 不自定义Cell的情况 设置Cell的preservesSuperviewLayoutMargins = NO、separatorInset = UIEdgeInsetsZero 、 layoutMargins = UIEdgeInsetsZero 或者设置tableview的 separatorInset = UIEdgeInsetsZero、再设置Cell的 preservesSuperviewLayoutMargins = NO、layoutMargins = UIEdgeInsetsZero 其实嘛，之所以会有边距都是separatorInset和layoutMargins这两个属性作祟，tableview和Cell同时都有这两个属性导致了两个单位的偏移，而separatorInset这个无论tableview设置还是Cell设置都是一样可以减少一个单位的偏移(即使两个都设置了也只是减一个单位) 另外一个重要原因是 layoutMargins这个属性,当你没有设置这个属性的时候，它会默认有 {8,8,8,8} 的偏移量，但是呢，即使你设置了tableview的 layoutMargins=UIEdgeInsetsZero ，你也会发现没用。这是因为另一个属性 preservesSuperviewLayoutMargins又在搞事情，这个属性的意思是保持父控件的layoutMargins属性的行为(大概吧（雾…）)默认是NO。也就是说，Cell本身的layoutMargins还是默认的 {8，8，8，8} ，因此还是有一个单位的偏移。。。但是啊但是(好多但是→_→)即使设置为YES也并没有什么效果，因为呀，Cell的父视图并不是TableView呢…而是一个叫UITableviewWrapperView的 此外，当你使用系统默认的UITableviewCell类的时候，preservesSuperviewLayoutMargins默认是为YES的，而自定义Cell的时候这个属性会自动置为NO 因此，我在这里要重新说明如何自定义TableView全屏的分割线如果自定义Cell的话只需要设置 tableview 或者 Cell的 separatorInset = UIEdgeInsetsZero 以及Cell的的layoutMargins =UIEdgeInsetsZero 这简单的两步就可以了!!! 如果使用系统的是UITableviewCell类的话就再多加上preservesSuperviewLayoutMargins = NO这句就可以了 —-PART Two—-去除没有数据的Cell或者指定Cell的分割线 想要去除没有数据的Cell的分割线的话非常简单，只需要设置tableviewFootView为一个空的View,那么下面没有数据的Cell的就不会显示了 另外一个是因为前几天刚好遇见个需求，就是要去除指定的某一个Cell的分割线。 那我们其实就可以利用separatorInset来完成这个需求只需要把分割线移除屏幕外或者把它压缩为0像素就可以了 效果很容易就达到了~~ 最后说几句—关于preservesSuperviewLayoutMargins属性还是无法理解它的作用…看了苹果文档，大概意思是如果设为Yes的话,则父控件内容的左边距会留出一个最小间距出来。虽然我说了Cell的父控件是UITableviewWrapperView，而且在CellForRow数据源方法中也拿不到它(因为Cell要在该方法返回后才被系统使用并添加到父控件上)，但是即使我在其他能拿到的地方拿到它了，并且设置了它的layoutMargins =UIEdgeInsetsZero和Cell的preservesSuperviewLayoutMargins = YES，可惜却也完全没有效果…如果大家有什么见解希望能告知一声~ 至此，我的个人见解说完了，谢谢大家的阅读~~~","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原生应用","slug":"iOSDevelopment/Native","permalink":"http://yoursite.com/categories/iOSDevelopment/Native/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"总结-layoutSubview的调用场景","slug":"总结-layoutSubview的调用场景","date":"2016-04-15T08:58:00.000Z","updated":"2018-01-09T03:53:42.000Z","comments":true,"path":"2016/04/15/总结-layoutSubview的调用场景/","link":"","permalink":"http://yoursite.com/2016/04/15/总结-layoutSubview的调用场景/","excerpt":"","text":"首先要起个代号(不然连我自己都会晕+_+) 视图A 、 被添加到视图A的子视图B 使用addSubview添加时会调用layoutSubView 在A开始被添加到父视图 (如果此时A没有frame 则不会调用layoutSubview) 添加B 到A的时候调用 (如果此时B有frame 则会调用) 设置A的父视图的Size时会调用 设置A的Size时会进行智能判断–&gt;仅当 Size与之前不同时，才会调用A的layoutSubview 设置B的frame时会调用(如果仅仅设置frame 但是没有调用过addSubview添加到父控件上 那么也不会调用layoutSubview ) 滚动scrollview 的时候也会调用 设备的orientation(方向)改变时,涉及改变的UIViewControl 的root view(此时所有的控件被重新布局,相当于A的frame被改变 那么会调用layoutSubview 而且如果控件有B的话会再调用一次layoutSubview) Resizing(拉伸) 一个 控件 也会调用它的父控件的layoutSubview 调用setNeedsLayout时 还有一个重要的点,layoutSubview不是在调用完比如addSubview等方法之后就马上调用,而是会在调用addSubview方法所在的作用域结束之后之后才调用,因此即使你在同一个方法中既使用了addSubViews又更改了frame，也是只会调用一次layoutSubview而已","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原理分析","slug":"iOSDevelopment/Analysis","permalink":"http://yoursite.com/categories/iOSDevelopment/Analysis/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"iOS中常用的数学函数","slug":"iOS中常用的数学函数","date":"2016-04-12T01:25:00.000Z","updated":"2018-01-09T03:54:08.000Z","comments":true,"path":"2016/04/12/iOS中常用的数学函数/","link":"","permalink":"http://yoursite.com/2016/04/12/iOS中常用的数学函数/","excerpt":"","text":"每一个函数都有对应计算float / double / long double 的函数,这里只列出double类型的 三角函数 double cos(double) 余弦 double sin(double) 正弦 double tan(double) 正切 反三角函数 double acos(double) 反余弦 结果介于[0, PI] double asin(double) 反正弦 结果介于[-PI/2, PI/2] double atan(double) 反正切 反正切(主值), 结果介于[-PI/2, PI/2] double atan2(double, double) 反正切 主要用法–根据给定的两个值求出对应的角度 比如给y和x,就可以求出该点相对（0，0）的角度 取整 double ceil (double) 向上取整 double floor (double) 向下取整 double fmod (double, double) 返回两参数相除的余数 指数与对数 double fabs(double) 求绝对值 double sqrt(double) 开方 double exp(double) 求取自然数e的幂 double log (double) 以e为底的对数 double log10 (double) 以10为底的对数 double pow(double x, double y） 计算以x为底数的y次幂 其他 double hypot(double x, double y) 已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent) 计算x*(2的exponent次幂)","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"整理一下OC中的那些属性修饰符","slug":"整理一下OC中的那些属性修饰符","date":"2016-04-11T15:21:00.000Z","updated":"2018-01-09T13:11:40.000Z","comments":true,"path":"2016/04/11/整理一下OC中的那些属性修饰符/","link":"","permalink":"http://yoursite.com/2016/04/11/整理一下OC中的那些属性修饰符/","excerpt":"","text":"首先从简单到复杂大致分个类1. 自定义getter | setter方法名修饰符 : getter和setter2. 原子性修饰符:atomic | nonatomic3. 读写性修饰符：readwrite | readonly4. setter相关修饰符：assign | retain | copy 方法名修饰符• getter=,setter=:指定该属性所使用的getter和setter方法的名称 两个属性修饰符用于设置自定义生成的getter和setter方法名，使用之后将不再使用系统默认的setter和getter方法名 • 用得不是很多，使用场景一般是对BOOL属性设置该getter方法，比如 isGood 这样用以方便判断时使用 原子修饰符•atomic : 原子属性,为setter方法加锁 (默认) (类似多线程中的互斥锁) § 线程安全,但需要消耗大量资源 • nonatomic : 非原子属性,不为setter方法加锁 § 非线程安全,适合内存小的移动设备 读写性修饰符• readwrite:表明这个属性是可读可写的，系统为我们生成这个属性的setter和getter方法以及下划线开头的成员变量。•readonly:表明这个属性只能读不能写，系统只为我们生成一个getter方法下划线开头的成员变量，不会创建setter方法 注意! 用readwrite自动生成setter和getter方法以及下划线开头的成员变量的时候，如果手动实现了setter和getter方法，那么系统将不会生成下划线开头成员变量 同理，readonly自动生成getter 方法和_开头成员变量时，如果手动实现了getter方法，那么系统也不会再生成下划线开头的成员变量 setter相关修饰符•retain:针对对象类型进行内存管理(非ARC)。当给对象类型使用此修饰符时，setter方法会先将旧的对象属性release掉，再对新的对象进行一次赋值并进行一次retain操作• assign:表示直接赋值， 基本数据类型、枚举、结构体(非OC对象) class类型当一个对象被销毁时，指针不会被清空(所以修饰对象时容易造成坏内存 (非ARC下会用这个修饰对象) • copy:以前主要用在NSString类型和Block，建立一个索引计数为1的对象，然后释放旧对象。 • strong ：除NSString\\block以外(注意!这是以前的说法)的OC对象 , 强引用以保证属性作用域结束后不被销毁 • weak : 当一个对象被销毁时，指针被清空 一般用在已经添加到父控件中的控件,因为父控件会对子控件进行引用,也就是retain,所以自己的作用域结束之后不会被释放 系统默认属性是assign。retain是指针的复制，copy是内容的复制 用copy修饰字符串时——&gt;1234在setter方法中会判断 传入的字符串 是否是可变的如果是可变的就分配新的内存再赋值如果是不可变的就直接赋值地址而实际上开发中其实大量使用的是不可变的字符串 所以最好使用 strong 修饰字符串,可以提升性能(减少一次判断) 用copy修饰Block时—-&gt;首先要知道Block在非ARC和ARC下的区别非ARC环境下: 123block访问外部局部变量,block存放栈里面只要block访问变量,而且是整个app都存在的变量,那么肯定在全局区在非ARC中.不能使用retain引用block,因为不会放在堆里面,在非ARC中只能使用copy,才会把block放在堆里面 ARC环境下:123只要block访问了外部局部变量,block就会存放到堆里面可以使用strong去引用 因为本身就已经是存放在堆区了也可以用copy，但是用stong性能更好 做个小总结(只说ARC环境下的) 用strong修饰OC对象以及NSString和Block , 没添加到父控件上的控件 用weak修饰已经被添加到父控件上的控件 以及 代理对象 用assign基本数据类型、枚举、结构体(非OC对象) class类型 用copy修饰一种情况下的NSString–&gt;不确定赋值过程中用的是可变还是不可变字符串","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原理分析","slug":"iOSDevelopment/Analysis","permalink":"http://yoursite.com/categories/iOSDevelopment/Analysis/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"在使用TablView时碰到Nan错误","slug":"在使用TablView时碰到Nan错误","date":"2016-04-07T15:14:00.000Z","updated":"2018-01-09T03:52:40.000Z","comments":true,"path":"2016/04/07/在使用TablView时碰到Nan错误/","link":"","permalink":"http://yoursite.com/2016/04/07/在使用TablView时碰到Nan错误/","excerpt":"","text":"前几天做项目的时候遇到一个奇葩的问题，程序本来运行得好好的，然后突然就崩了，报了一个Nan错误 Terminating app due to uncaught exception 'CALayerInvalidGeometry', reason: 'CALayer position contains NaN: [187.5 nan]'1 后来打了一大堆断点发现数据源方法返回cell高度的时候出现了Nan类型，结合该cell对应的模型才发现是网络数据返回了一个 0 数据，而我把这个数据作为除数来计算了，因此出现了Nan类型。 这种错误是在float经过函数运行出了不是数字的值，nan的意思就是not a number 后来解决了问题再去百度的时候发现出现Nan错误的不止除以0这种情况，还有以下几种(以后要多注意一下) 1.除以02.sizeWithFont的字符串为nil3.数学函数不正确运算解决方法除了排除数据源以及运算问题之外,还可以用isnan()函数判断是不是Nan类型_x 123if (!isnan(_x)) &#123;return _x;&#125; 文中部分内容引自这里","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"关于模拟器上键盘输入的一些小问题","slug":"关于模拟器上键盘输入的一些小问题","date":"2016-04-04T04:38:00.000Z","updated":"2018-01-09T12:49:51.000Z","comments":true,"path":"2016/04/04/关于模拟器上键盘输入的一些小问题/","link":"","permalink":"http://yoursite.com/2016/04/04/关于模拟器上键盘输入的一些小问题/","excerpt":"","text":"平时用模拟器键盘输入的时候总会有一大堆令人无语的自动联想、纠错、拼写检查…不胜其烦！本来一直以为是输入法的问题，后来才发现原来是苹果做的小优化…… 不知道大家平时在做测试的时候有没有经常遇到下面的这些这种情况呢~~ 没错就是它，有时候做登录界面测试是时老是弹出来，输完自己正确的账号或密码之后以为可以了结果它一个回马枪”帮”你把错误”修正”了，我还要重新输一遍还要小心翼翼地点那个小叉叉,妈的智障！ @property(nonatomic) UITextAutocorrectionType autocorrectionType;找了半天，原来是这个自动纠错属性在作怪，查看了一下它的枚举值，也就一个默认一个yes一个no，高兴得我立马把它改UITextAutocorrectionTypeNo，结果当然是整个世界都清净啦~~(≧▽≦)/~啦啦啦 另外，除了上面那个比较坑的之外，还有下面这个这个自动联想功能嘛，有人喜欢有人嫌…不过有时候真的挺烦它的，联想的东西几乎没卵用，顺手把它干掉吧~ @property(nonatomic)UITextAutocapitalizationType autocapitalizationType;它有四个枚举值UITextAutocapitalizationTypeNone, 不进行联想UITextAutocapitalizationTypeWords, 单词联想UITextAutocapitalizationTypeSentences, 整句联想UITextAutocapitalizationTypeAllCharacters, 所有字节都联想 然后是在找这些个属性的时候发现的其他属性,感觉挺有用的，这些平时在Storyboard也能见到的，只不过代码似乎用得比较少~~ @property(nonatomic) UITextSpellCheckingType spellCheckingType自动拼写检查，好像平时没怎么见它发挥作用… @property(nonatomic) UIKeyboardAppearance keyboardAppearance;键盘外观？？？其实也就一个日用一个夜用~~ @property(nonatomic) BOOL enablesReturnKeyAutomatically;以前我一直以为这个Return按钮的disable状态要自己控制，今天才发现原来苹果已经做好了,只要输入内容长度为0按钮就不可用… @property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;安全输入，也就是暗文,做密码输入用的 @property(nonatomic) UIKeyboardType keyboardType;键盘类型，自己测试了，但是有一些感觉跟其他的键盘长得一模一样，也不知道区别在哪里，就没有做记录了 @property(nonatomic) UIKeyboardType keyboardType;Return按钮的类型，这里列举几个常用的，其他的就自己看吧 ~ 这些个属性都是定义在UITextInputTraits协议里面的，而且UITextField 和 UITextView 都遵守了，所以都可以使用。不过呢，其实这些在Storyboard里面都可以找得到的…","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"项目/日常问题","slug":"iOSDevelopment/Project-daily","permalink":"http://yoursite.com/categories/iOSDevelopment/Project-daily/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"关于MJRefresh","slug":"关于MJRefresh","date":"2016-03-30T09:04:00.000Z","updated":"2018-01-09T03:51:13.000Z","comments":true,"path":"2016/03/30/关于MJRefresh/","link":"","permalink":"http://yoursite.com/2016/03/30/关于MJRefresh/","excerpt":"","text":"刚弄清楚MJReFresh每一个类主要的作用，写下来方便以后查看 • MJRefreshComponent 刷新控件的基类 KVO监听ScrollerView的ContentOffset 和 ContentSize 以及 刷新手势 • UIScrollView+MJRefresh 对UIScrollView添加了上拉下拉刷新控件 以及刷新回调Block• MJRefreshHeader 头部刷新控件 自带记录刷新时间 ○ MJRefreshStateHeader 可以自定义文字 § MJRefreshNormalHeader 可以设置菊花样式 § MJRefreshGifHeader 可自定义刷新控件的动态图片 • MJRefreshFooter 底部刷新控件 自带记录刷新时间 ○ MJRefreshAutoFooter 可自定义文字 § MJRefreshAutoStateFooter 可设置底部出现多少时自动刷新 □ MJRefreshAutoNormalFooter 可以自定义文字 □ MJRefreshAutoGifFooter 可自定义刷新控件的动态图片 § MJRefreshBackFooter 未提供接口,内部实现了刷新后回弹效果 □ MJRefreshBackStateFooter 可以自定义文字 ® MJRefreshBackGifFooter 可自定义刷新控件的动态图片 ® MJRefreshBackNormalFooter 可设置菊花样式","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"第三方框架相关","slug":"iOSDevelopment/Framework","permalink":"http://yoursite.com/categories/iOSDevelopment/Framework/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"协议和代理","slug":"协议和代理","date":"2016-03-27T17:09:00.000Z","updated":"2018-01-09T03:52:13.000Z","comments":true,"path":"2016/03/28/协议和代理/","link":"","permalink":"http://yoursite.com/2016/03/28/协议和代理/","excerpt":"","text":"protocol-协议，就是使用了这个协议后就要按照这个协议来办事，协议要求实现的方法就一定要实现。delegate-委托，顾名思义就是委托别人办事，就是当一件事情发生后，自己不处理，让别人来处理。 编写规范1&gt;一般情况下,当前协议属于谁,我们就将协议定义到谁的头文件中2&gt;协议的名称一般以它属于的那个类的类名开头,后面跟上protocol 或者 delegate3&gt;协议中的方法名称一般以协议的名称protocol之前的作为开头4&gt;一般情况下协议中的方法会将触发该协议的对象传递出去5&gt;一般情况下 类中都会有一个叫delegate 的属性6&gt;当某一个类要成为另外一个类的代理的时候,一般情况下: .h中用@protocol 协议名称;告诉当前类这是一个协议 在.m中用#import 真正的导入一个协议的声明7&gt;协议必须遵守基协议","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"面试问题","slug":"iOSDevelopment/InterviewFAQ","permalink":"http://yoursite.com/categories/iOSDevelopment/InterviewFAQ/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"UITabBarController","slug":"UITabBarController","date":"2016-03-26T07:02:00.000Z","updated":"2018-01-09T03:54:34.000Z","comments":true,"path":"2016/03/26/UITabBarController/","link":"","permalink":"http://yoursite.com/2016/03/26/UITabBarController/","excerpt":"","text":"UITabBarController与UINavigationController有些类似又有些区别，因此最好通过两个控制器的对比来了解其结构。 从共同点看 它们都是通过一个childViewControllers数组来存储子控制器以强引用它们，然后把它们对应的View显示到屏幕上 UINavigationController有一个NavigationBar始终显示在最前面，UITabBarController也有一个tabBar始终显示在最前面 从不同点看 显示子控制器的View UINavigationController只有在需要显示某个控制器的View的时候才会加载该View并且把原本显示的View移除(这里只是移除View，但是控制器并没有移除) UITabBarController则是在一开始显示的时候就把所有的View都加载进内存，需要显示某个View的时候就直接拿过来，原本的View也不会被移除 导航条和标签栏 导航条的y值是从20开始的, 但内部有一个UIImageView子控件超过导航条高度，因此看到的是64高度，此外 导航条底部还有一个子控件 -&gt; 一根线(一张阴影图片) 一个导航控制器只有一个NavigationBar也就是所有的子控制器共用同一个导航条，导航条显示的内容和栈顶控制器有关,所以导航条上显示的内容由栈顶控制器控制 标签栏的高度为49，它的子控件除了与子控制器相对应的UITabBarButton按钮还有 背景UIImageView和分割线UIVIew 在子控制器中是无法拿到TabBar的,只能拿到UItabBarItem 来设置 暂时了解的也就这些了，以后认识更加深刻再来补上...","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原理分析","slug":"iOSDevelopment/Analysis","permalink":"http://yoursite.com/categories/iOSDevelopment/Analysis/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]},{"title":"+load和+initialize的区别","slug":"+load和+initialize的区别","date":"2016-03-26T03:24:00.000Z","updated":"2018-01-09T03:53:11.000Z","comments":true,"path":"2016/03/26/+load和+initialize的区别/","link":"","permalink":"http://yoursite.com/2016/03/26/+load和+initialize的区别/","excerpt":"","text":"在不考虑一切继承、分类的最简单最普通的情况下： 调用时刻: load:程序启动时,类被加载进内存就调用initialize:当第一次使用这个类或者其子类就会调用 调用次数 load:因为加载进内存只会加载一次，所以也只会调用一次initialize:不确定,具体根据子类和具体调用情况比如有个类,它有一个子类,第一次使用子类时,父类的initialize会被调用2次 上面说的只是普通情况。但是呢，一个类可能继承于某个super类，还有可能有自己的分类，如果分类中也实现了load方法，它们的调用顺序是怎么样的呢？ 这里需要知道—&gt;覆盖方法在分类中的体现如果父类本身中的方法在子类中被重写，则会优先执行子类中的方法如果类本身中的方法在分类中被重写，则会优先执行分类中的方法 但是这里必须要知道一个特例-&gt;+load 系统首先会调用 super类的load方法，然后再调用该类自身的load方法，再次才会调用该类的分类重写的load方法，也即是说整个继承链包括分类扩展中的load方法都会被执行，只是执行顺序需要关注一下。 也就是说，假如你重写了某个类的load方法，同时又在该类的分类中也重写了load方法，你就会发现这个类的load被调用了两次。","categories":[{"name":"iOS开发","slug":"iOSDevelopment","permalink":"http://yoursite.com/categories/iOSDevelopment/"},{"name":"原理分析","slug":"iOSDevelopment/Analysis","permalink":"http://yoursite.com/categories/iOSDevelopment/Analysis/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://yoursite.com/tags/iOS开发/"}]}]}