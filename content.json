{"meta":{"title":"尛孟の博客","subtitle":"想法总是无法付诸实践…","description":"与人联系甚少","author":"尛孟","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-04T10:07:40.000Z","updated":"2018-01-04T10:08:48.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-04T10:07:23.000Z","updated":"2018-01-04T10:08:23.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T10:07:33.000Z","updated":"2018-01-04T10:08:39.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"沙盒文件夹的作用和选择","slug":"沙盒文件夹的作用和选择","date":"2016-04-18T10:56:00.000Z","updated":"2018-01-08T05:46:52.000Z","comments":true,"path":"2016/04/18/沙盒文件夹的作用和选择/","link":"","permalink":"http://yoursite.com/2016/04/18/沙盒文件夹的作用和选择/","excerpt":"","text":"沙盒大家都知道，但是平时要存储数据时总不知道存到哪里去才是正确的选择，这次就来聊聊每一个文件夹的作用和使用时该怎么选择 先来了解每一个文件夹的基本作用 • Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。• tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录• Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据• Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录 （看完还是不知道到底存哪里比较好啊喂(╯’ - ‘)╯︵ ┻━┻ ） – Documents– 需要保存由”应用程序本身”产生的文件或者数据，例如：游戏进度、涂鸦软件的绘图信息– 目录中的文件会被自动保存在 iClioud– 注意 ： 不要保存从网络上下载的文件，否则会无法上架 – Caches– 保存临时文件，”后续需要使用”，例如：缓存图片、离线数据(地图数据等)– 系统不会清零 cache 目录中的文件 –&gt; 因此要求程序开发时，”必须提供 cache 目录的清理解决方案” – Preference– 用户偏好设置，使用 NSUserDefault 直接读写 – Tmp– 保存临时文件，”后续不需要使用”– tmp 目录中的文件，系统会自动清零– 重新启动手机时，tmp 目录会被情况– 系统磁盘空间不足时，系统也会自动清理","categories":[],"tags":[]},{"title":"代理/通知/KVO 的区别","slug":"代理:通知:KVO 的区别","date":"2016-04-16T17:15:00.000Z","updated":"2018-01-08T05:47:46.000Z","comments":true,"path":"2016/04/17/代理:通知:KVO 的区别/","link":"","permalink":"http://yoursite.com/2016/04/17/代理:通知:KVO 的区别/","excerpt":"","text":"通知 NSNotification、通知中心 NSNotificationCenter◦ 任何对象之间都可以传递消息(一般在层级结构比较深又需要传值的情况) 使用范围▪ 1个对象可以发通知给多个对象▪ 1个对象可以接受多个对象发出的通知◦ 要求:必须得保证通知的名字在发出和监听时是一致的 KVO◦ 仅仅是能监听对象属性的改变（灵活度不如通知和代理） 代理模式 使用范围▪ 1个对象只能设置一个代理(假设这个对象只有1个代理属性)▪ 1个对象能成为多个对象的代理 如何选择?◦ 代理比通知规范，非常适合多人开发以及代码维护◦ 如果要通知多个对象,就用通知 ◦ 建议使用代理多于通知,能使用代理尽量使用代理◦ 当层级结构非常深，难以拿到对应对象时使用通知","categories":[],"tags":[]},{"title":"纠正网上大部分文章对UITableView分割线的不正确认识","slug":"纠正网上大部分文章对UITableView分割线的不正确认识","date":"2016-04-16T06:04:00.000Z","updated":"2018-01-08T07:32:36.000Z","comments":true,"path":"2016/04/16/纠正网上大部分文章对UITableView分割线的不正确认识/","link":"","permalink":"http://yoursite.com/2016/04/16/纠正网上大部分文章对UITableView分割线的不正确认识/","excerpt":"","text":"本篇文章主要有两个内容:1. 正确认识全屏分割线的设置 2. 去除没有数据的Cell或者指定Cell的分割线 毕竟这里只是我自己本人的看法和总结 – 有什么建议或者觉得我说得不好的地方，欢迎互相探讨。毕竟探讨越多提升越大~~ —-PART One—-首先是我一直觉得很不爽的全屏分割线(为何不爽,看完这一部分大家应该也能理解我的感受) 自定义Cell的情况 把系统的分割线隐藏,然后自己创建一个高度为1的UIVIew添加到Cell的底部或者顶部 把系统的分割线隐藏,然后设置tableview的背景色为自己想要的分割线颜色，重写Cell的setFrame方法，把高度减1(需要的话还可以把宽度也减一点点，会有不一样的效果~) 设置Cell的1- 或者设置tableview的```separatorInset = UIEdgeInsetsZero```、再设置Cell的 ```layoutMargins = UIEdgeInsetsZero 不自定义Cell的情况 设置Cell的preservesSuperviewLayoutMargins = NO、separatorInset = UIEdgeInsetsZero 、 layoutMargins = UIEdgeInsetsZero 或者设置tableview的 separatorInset = UIEdgeInsetsZero、再设置Cell的 preservesSuperviewLayoutMargins = NO、layoutMargins = UIEdgeInsetsZero 其实嘛，之所以会有边距都是12345678910111213141516171819202122232425262728293031323334353637383940414243tableview和Cell同时都有这两个属性导致了两个单位的偏移，而separatorInset这个无论tableview设置还是Cell设置都是一样可以减少一个单位的偏移(即使两个都设置了也只是减一个单位)&gt;&gt; 另外一个重要原因是 ```layoutMargins``` 这个属性,当你没有设置这个属性的时候，它会默认有 &#123;8,8,8,8&#125; 的偏移量，&gt;&gt; 但是呢，即使你设置了tableview的 layoutMargins=UIEdgeInsetsZero ，你也会发现没用。&gt;&gt; 这是因为另一个属性 ``` preservesSuperviewLayoutMargins ``` 又在搞事情，&gt;&gt; 这个属性的意思是保持父控件的layoutMargins属性的行为(大概吧（雾...）)默认是NO。&gt;&gt; 也就是说，Cell本身的layoutMargins还是默认的 &#123;8，8，8，8&#125; ，因此还是有一个单位的偏移。。。&gt;&gt; 但是啊但是(好多但是→_→)即使设置为YES也并没有什么效果，&gt;&gt; 因为呀，Cell的父视图并不是TableView呢...而是一个叫UITableviewWrapperView的![UITableViewSeparator_1.png](http://i4.bvimg.com/627154/5e984750fa50744d.png)&gt;&gt; 此外，当你使用系统默认的UITableviewCell类的时候，preservesSuperviewLayoutMargins默认是为YES的，而自定义Cell的时候这个属性会自动置为NO--- ** 因此，我在这里要重新说明如何自定义TableView全屏的分割线如果自定义Cell的话只需要设置 tableview 或者 Cell的 ```separatorInset = UIEdgeInsetsZero ```以及Cell的````的layoutMargins =UIEdgeInsetsZero ````这简单的两步就可以了!!! 如果使用系统的是UITableviewCell类的话就再多加上```preservesSuperviewLayoutMargins = NO```这句就可以了 **--- #### ----PART Two----去除没有数据的Cell或者指定Cell的分割线&gt; 想要去除没有数据的Cell的分割线的话非常简单，只需要设置tableviewFootView为一个空的View,那么下面没有数据的Cell的就不会显示了![UITableViewSeparator_2.png](http://i4.bvimg.com/627154/935f75e4710580e0.png)---&gt; 另外一个是因为前几天刚好遇见个需求，就是要去除指定的某一个Cell的分割线。那我们其实就可以利用```separatorInset``` 来完成这个需求只需要把分割线移除屏幕外或者把它压缩为0像素就可以了![UITableViewSeparator_3.png](http://i4.bvimg.com/627154/1b4be2a5e95fd599.png)效果很容易就达到了~~![UITableViewSeparator_4.png](http://i4.bvimg.com/627154/d27a8a6ae045078b.png)--- ###### 最后说几句---```关于preservesSuperviewLayoutMargins属性还是无法理解它的作用...看了苹果文档，大概意思是如果设为Yes的话,则父控件内容的左边距会留出一个最小间距出来。虽然我说了Cell的父控件是UITableviewWrapperView，而且在CellForRow数据源方法中也拿不到它(因为Cell要在该方法返回后才被系统使用并添加到父控件上)，但是即使我在其他能拿到的地方拿到它了，并且设置了它的```layoutMargins =UIEdgeInsetsZero和Cell的preservesSuperviewLayoutMargins = YES```，可惜却也完全没有效果...如果大家有什么见解希望能告知一声~~~ 至此，我的个人见解说完了，谢谢大家的阅读~~~","categories":[],"tags":[]},{"title":"总结-layoutSubview的调用场景","slug":"总结-layoutSubview的调用场景","date":"2016-04-15T08:58:00.000Z","updated":"2018-01-08T05:45:05.000Z","comments":true,"path":"2016/04/15/总结-layoutSubview的调用场景/","link":"","permalink":"http://yoursite.com/2016/04/15/总结-layoutSubview的调用场景/","excerpt":"","text":"首先要起个代号(不然连我自己都会晕+_+) 视图A 、 被添加到视图A的子视图B 使用addSubview添加时会调用layoutSubView 在A开始被添加到父视图 (如果此时A没有frame 则不会调用layoutSubview) 添加B 到A的时候调用 (如果此时B有frame 则会调用) 设置A的父视图的Size时会调用 设置A的Size时会进行智能判断–&gt;仅当 Size与之前不同时，才会调用A的layoutSubview 设置B的frame时会调用(如果仅仅设置frame 但是没有调用过addSubview添加到父控件上 那么也不会调用layoutSubview ) 滚动scrollview 的时候也会调用 设备的orientation(方向)改变时,涉及改变的UIViewControl 的root view(此时所有的控件被重新布局,相当于A的frame被改变 那么会调用layoutSubview 而且如果控件有B的话会再调用一次layoutSubview) Resizing(拉伸) 一个 控件 也会调用它的父控件的layoutSubview 调用setNeedsLayout时 还有一个重要的点,layoutSubview不是在调用完比如addSubview等方法之后就马上调用,而是会在调用addSubview方法所在的作用域结束之后之后才调用,因此即使你在同一个方法中既使用了addSubViews又更改了frame，也是只会调用一次layoutSubview而已","categories":[],"tags":[]},{"title":"iOS中常用的数学函数","slug":"iOS中常用的数学函数","date":"2016-04-12T01:25:00.000Z","updated":"2018-01-08T05:44:10.000Z","comments":true,"path":"2016/04/12/iOS中常用的数学函数/","link":"","permalink":"http://yoursite.com/2016/04/12/iOS中常用的数学函数/","excerpt":"","text":"每一个函数都有对应计算float / double / long double 的函数,这里只列出double类型的 三角函数 double cos(double) 余弦 double sin(double) 正弦 double tan(double) 正切 反三角函数 double acos(double) 反余弦 结果介于[0, PI] double asin(double) 反正弦 结果介于[-PI/2, PI/2] double atan(double) 反正切 反正切(主值), 结果介于[-PI/2, PI/2] double atan2(double, double) 反正切 主要用法–根据给定的两个值求出对应的角度 比如给y和x,就可以求出该点相对（0，0）的角度 取整 double ceil (double) 向上取整 double floor (double) 向下取整 double fmod (double, double) 返回两参数相除的余数 指数与对数 double fabs(double) 求绝对值 double sqrt(double) 开方 double exp(double) 求取自然数e的幂 double log (double) 以e为底的对数 double log10 (double) 以10为底的对数 double pow(double x, double y） 计算以x为底数的y次幂 其他 double hypot(double x, double y) 已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent) 计算x*(2的exponent次幂)","categories":[],"tags":[]},{"title":"整理一下OC中的那些属性修饰符","slug":"整理一下OC中的那些属性修饰符","date":"2016-04-11T15:21:00.000Z","updated":"2018-01-08T06:03:41.000Z","comments":true,"path":"2016/04/11/整理一下OC中的那些属性修饰符/","link":"","permalink":"http://yoursite.com/2016/04/11/整理一下OC中的那些属性修饰符/","excerpt":"","text":"首先从简单到复杂大致分个类1. 自定义getter | setter方法名修饰符 : getter和setter2. 原子性修饰符:atomic | nonatomic3. 读写性修饰符：readwrite | readonly4. setter相关修饰符：assign | retain | copy 方法名修饰符• getter=,setter=:指定该属性所使用的getter和setter方法的名称 这两个属性修饰符用于设置自定义生成的getter和setter方法名，使用之后将不再使用系统默认的setter和getter方法名• 用得不是很多，使用场景一般是对BOOL属性设置该getter方法，比如 isGood 这样用以方便判断时使用 原子修饰符• atomic : 原子属性,为setter方法加锁 (默认) (类似多线程中的互斥锁)§ 线程安全,但需要消耗大量资源• nonatomic : 非原子属性,不为setter方法加锁§ 非线程安全,适合内存小的移动设备 读写性修饰符• readwrite:表明这个属性是可读可写的，系统为我们生成这个属性的setter和getter方法以及下划线开头的成员变量。• readonly:表明这个属性只能读不能写，系统只为我们生成一个getter方法下划线开头的成员变量，不会创建setter方法 注意!用readwrite自动生成setter和getter方法以及下划线开头的成员变量的时候，如果手动实现了setter和getter方法，那么系统将不会生成下划线开头成员变量```1234![Snip20160411_16.png](http://upload-images.jianshu.io/upload_images/1635441-ed7e0ee1efc0fc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![Snip20160411_17.png](http://upload-images.jianshu.io/upload_images/1635441-1a93659e77ca2568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)*** ###### ```• 同理，readonly自动生成getter 方法和_开头成员变量时，如果手动实现了getter方法，那么系统也不会再生成下划线开头的成员变量 ##setter相关修饰符• retain:针对对象类型进行内存管理(非ARC)。当给对象类型使用此修饰符时，setter方法会先将旧的对象属性release掉，再对新的对象进行一次赋值并进行一次retain操作• assign:表示直接赋值， 基本数据类型、枚举、结构体(非OC对象) class类型当一个对象被销毁时，指针不会被清空(所以修饰对象时容易造成坏内存 (非ARC下会用这个修饰对象) • copy:以前主要用在NSString类型和Block，建立一个索引计数为1的对象，然后释放旧对象。• strong ：除NSString\\block以外(注意!这是以前的说法)的OC对象 , 强引用以保证属性作用域结束后不被销毁• weak : 当一个对象被销毁时，指针被清空一般用在已经添加到父控件中的控件,因为父控件会对子控件进行引用,也就是retain,所以自己的作用域结束之后不会被释放系统默认属性是assign。retain是指针的复制，copy是内容的复制 用copy修饰字符串时—-&gt;&gt;在setter方法中会判断 传入的字符串 是否是可变的如果是可变的就分配新的内存再赋值如果是不可变的就直接赋值地址而实际上开发中其实大量使用的是不可变的字符串 所以最好使用 strong 修饰字符串,可以提升性能(减少一次判断) 用copy修饰Block时—-&gt;首先要知道Block在非ARC和ARC下的区别非ARC环境下:block访问外部局部变量,block存放栈里面只要block访问变量,而且是整个app都存在的变量,那么肯定在全局区在非ARC中.不能使用retain引用block,因为不会放在堆里面,在非ARC中只能使用copy,才会把block放在堆里面 ARC环境下:只要block访问了外部局部变量,block就会存放到堆里面可以使用strong去引用 因为本身就已经是存放在堆区了也可以用copy，但是用stong性能更好 做个小总结(只说ARC环境下的) , 没添加到父控件上的控件```1```用weak修饰已经被添加到父控件上的控件 以及 代理对象 class类型 ```1```用copy修饰一种情况下的NSString--&gt;不确定赋值过程中用的是可变还是不可变字符串","categories":[],"tags":[]},{"title":"在使用TablView时碰到Nan错误","slug":"在使用TablView时碰到Nan错误","date":"2016-04-07T15:14:00.000Z","updated":"2018-01-08T05:49:48.000Z","comments":true,"path":"2016/04/07/在使用TablView时碰到Nan错误/","link":"","permalink":"http://yoursite.com/2016/04/07/在使用TablView时碰到Nan错误/","excerpt":"","text":"前几天做项目的时候遇到一个奇葩的问题，程序本来运行得好好的，然后突然就崩了，报了一个Nan错误 Terminating app due to uncaught exception 'CALayerInvalidGeometry', reason: 'CALayer position contains NaN: [187.5 nan]'1 后来打了一大堆断点发现数据源方法返回cell高度的时候出现了Nan类型，结合该cell对应的模型才发现是网络数据返回了一个 0 数据，而我把这个数据作为除数来计算了，因此出现了Nan类型。 这种错误是在float经过函数运行出了不是数字的值，nan的意思就是not a number 后来解决了问题再去百度的时候发现出现Nan错误的不止除以0这种情况，还有以下几种(以后要多注意一下) 1.除以02.sizeWithFont的字符串为nil3.数学函数不正确运算解决方法除了排除数据源以及运算问题之外,还可以用isnan()函数判断是不是Nan类型_x 123if (!isnan(_x)) &#123;return _x;&#125; 文中部分内容引自这里","categories":[],"tags":[]},{"title":"关于模拟器上键盘输入的一些小问题","slug":"关于模拟器上键盘输入的一些小问题","date":"2016-04-04T04:38:00.000Z","updated":"2018-01-08T06:44:50.000Z","comments":true,"path":"2016/04/04/关于模拟器上键盘输入的一些小问题/","link":"","permalink":"http://yoursite.com/2016/04/04/关于模拟器上键盘输入的一些小问题/","excerpt":"","text":"平时用模拟器键盘输入的时候总会有一大堆令人无语的自动联想、纠错、拼写检查…不胜其烦！本来一直以为是输入法的问题，后来才发现原来是苹果做的小优化…… 不知道大家平时在做测试的时候有没有经常遇到下面的这些这种情况呢~~ 没错就是它，有时候做登录界面测试是时老是弹出来，输完自己正确的账号或密码之后以为可以了结果它一个回马枪”帮”你把错误”修正”了，我还要重新输一遍还要小心翼翼地点那个小叉叉,妈的智障！ @property(nonatomic) UITextAutocorrectionType autocorrectionType;找了半天，原来是这个自动纠错属性在作怪，查看了一下它的枚举值，也就一个默认一个yes一个no，高兴得我立马把它改UITextAutocorrectionTypeNo，结果当然是整个世界都清净啦~~(≧▽≦)/~啦啦啦 另外，除了上面那个比较坑的之外，还有下面这个这个自动联想功能嘛，有人喜欢有人嫌…不过有时候真的挺烦它的，联想的东西几乎没卵用，顺手把它干掉吧~ @property(nonatomic)UITextAutocapitalizationType autocapitalizationType;它有四个枚举值UITextAutocapitalizationTypeNone, 不进行联想UITextAutocapitalizationTypeWords, 单词联想UITextAutocapitalizationTypeSentences, 整句联想UITextAutocapitalizationTypeAllCharacters, 所有字节都联想 然后是在找这些个属性的时候发现的其他属性,感觉挺有用的，这些平时在Storyboard也能见到的，只不过代码似乎用得比较少~~ @property(nonatomic) UITextSpellCheckingType spellCheckingType自动拼写检查，好像平时没怎么见它发挥作用… @property(nonatomic) UIKeyboardAppearance keyboardAppearance;键盘外观？？？其实也就一个日用一个夜用~~ @property(nonatomic) BOOL enablesReturnKeyAutomatically;以前我一直以为这个Return按钮的disable状态要自己控制，今天才发现原来苹果已经做好了,只要输入内容长度为0按钮就不可用… @property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;安全输入，也就是暗文,做密码输入用的 @property(nonatomic) UIKeyboardType keyboardType;键盘类型，自己测试了，但是有一些感觉跟其他的键盘长得一模一样，也不知道区别在哪里，就没有做记录了 @property(nonatomic) UIKeyboardType keyboardType;Return按钮的类型，这里列举几个常用的，其他的就自己看吧 ~ 这些个属性都是定义在UITextInputTraits协议里面的，而且UITextField 和 UITextView 都遵守了，所以都可以使用。不过呢，其实这些在Storyboard里面都可以找得到的…","categories":[],"tags":[]},{"title":"关于MJRefresh","slug":"关于MJRefresh","date":"2016-03-30T09:04:00.000Z","updated":"2018-01-08T05:54:54.000Z","comments":true,"path":"2016/03/30/关于MJRefresh/","link":"","permalink":"http://yoursite.com/2016/03/30/关于MJRefresh/","excerpt":"","text":"刚弄清楚MJReFresh每一个类主要的作用，写下来方便以后查看 • MJRefreshComponent 刷新控件的基类 KVO监听ScrollerView的ContentOffset 和 ContentSize 以及 刷新手势 • UIScrollView+MJRefresh 对UIScrollView添加了上拉下拉刷新控件 以及刷新回调Block• MJRefreshHeader 头部刷新控件 自带记录刷新时间 ○ MJRefreshStateHeader 可以自定义文字 § MJRefreshNormalHeader 可以设置菊花样式 § MJRefreshGifHeader 可自定义刷新控件的动态图片 • MJRefreshFooter 底部刷新控件 自带记录刷新时间 ○ MJRefreshAutoFooter 可自定义文字 § MJRefreshAutoStateFooter 可设置底部出现多少时自动刷新 □ MJRefreshAutoNormalFooter 可以自定义文字 □ MJRefreshAutoGifFooter 可自定义刷新控件的动态图片 § MJRefreshBackFooter 未提供接口,内部实现了刷新后回弹效果 □ MJRefreshBackStateFooter 可以自定义文字 ® MJRefreshBackGifFooter 可自定义刷新控件的动态图片 ® MJRefreshBackNormalFooter 可设置菊花样式","categories":[],"tags":[]},{"title":"协议和代理","slug":"协议和代理","date":"2016-03-27T17:09:00.000Z","updated":"2018-01-08T05:43:35.000Z","comments":true,"path":"2016/03/28/协议和代理/","link":"","permalink":"http://yoursite.com/2016/03/28/协议和代理/","excerpt":"","text":"protocol-协议，就是使用了这个协议后就要按照这个协议来办事，协议要求实现的方法就一定要实现。delegate-委托，顾名思义就是委托别人办事，就是当一件事情发生后，自己不处理，让别人来处理。 编写规范1&gt;一般情况下,当前协议属于谁,我们就将协议定义到谁的头文件中2&gt;协议的名称一般以它属于的那个类的类名开头,后面跟上protocol 或者 delegate3&gt;协议中的方法名称一般以协议的名称protocol之前的作为开头4&gt;一般情况下协议中的方法会将触发该协议的对象传递出去5&gt;一般情况下 类中都会有一个叫delegate 的属性6&gt;当某一个类要成为另外一个类的代理的时候,一般情况下: .h中用@protocol 协议名称;告诉当前类这是一个协议 在.m中用#import 真正的导入一个协议的声明7&gt;协议必须遵守基协议","categories":[],"tags":[]},{"title":"UITabBarController","slug":"UITabBarController","date":"2016-03-26T07:02:00.000Z","updated":"2018-01-08T05:58:55.000Z","comments":true,"path":"2016/03/26/UITabBarController/","link":"","permalink":"http://yoursite.com/2016/03/26/UITabBarController/","excerpt":"","text":"UITabBarController与UINavigationController有些类似又有些区别，因此最好通过两个控制器的对比来了解其结构。 从共同点看 它们都是通过一个childViewControllers数组来存储子控制器以强引用它们，然后把它们对应的View显示到屏幕上 UINavigationController有一个NavigationBar始终显示在最前面，UITabBarController也有一个tabBar始终显示在最前面 从不同点看 显示子控制器的View UINavigationController只有在需要显示某个控制器的View的时候才会加载该View并且把原本显示的View移除(这里只是移除View，但是控制器并没有移除) UITabBarController则是在一开始显示的时候就把所有的View都加载进内存，需要显示某个View的时候就直接拿过来，原本的View也不会被移除 导航条和标签栏 导航条的y值是从20开始的, 但内部有一个UIImageView子控件超过导航条高度，因此看到的是64高度，此外 导航条底部还有一个子控件 -&gt; 一根线(一张阴影图片) 一个导航控制器只有一个NavigationBar也就是所有的子控制器共用同一个导航条，导航条显示的内容和栈顶控制器有关,所以导航条上显示的内容由栈顶控制器控制 标签栏的高度为49，它的子控件除了与子控制器相对应的UITabBarButton按钮还有 背景UIImageView和分割线UIVIew 在子控制器中是无法拿到TabBar的,只能拿到UItabBarItem 来设置 暂时了解的也就这些了，以后认识更加深刻再来补上...","categories":[],"tags":[]},{"title":"+load和+initialize的区别","slug":"+load和+initialize的区别","date":"2016-03-26T03:24:00.000Z","updated":"2018-01-08T05:32:55.000Z","comments":true,"path":"2016/03/26/+load和+initialize的区别/","link":"","permalink":"http://yoursite.com/2016/03/26/+load和+initialize的区别/","excerpt":"","text":"在不考虑一切继承、分类的最简单最普通的情况下： 调用时刻: load:程序启动时,类被加载进内存就调用initialize:当第一次使用这个类或者其子类就会调用 调用次数 load:因为加载进内存只会加载一次，所以也只会调用一次initialize:不确定,具体根据子类和具体调用情况比如有个类,它有一个子类,第一次使用子类时,父类的initialize会被调用2次 上面说的只是普通情况。但是呢，一个类可能继承于某个super类，还有可能有自己的分类，如果分类中也实现了load方法，它们的调用顺序是怎么样的呢？ 这里需要知道—&gt;覆盖方法在分类中的体现如果父类本身中的方法在子类中被重写，则会优先执行子类中的方法如果类本身中的方法在分类中被重写，则会优先执行分类中的方法 但是这里必须要知道一个特例-&gt;+load 系统首先会调用 super类的load方法，然后再调用该类自身的load方法，再次才会调用该类的分类重写的load方法，也即是说整个继承链包括分类扩展中的load方法都会被执行，只是执行顺序需要关注一下。 也就是说，假如你重写了某个类的load方法，同时又在该类的分类中也重写了load方法，你就会发现这个类的load被调用了两次。","categories":[],"tags":[]}]}